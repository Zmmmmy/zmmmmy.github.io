<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zmmmmy.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":"auto","version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="属性数据结构遍历详解概述属性数据结构 是指具有特定属性或特征的数据结构，如有序性、层级性、连通性等。遍历是访问数据结构中所有元素的基本操作，不同的数据结构有不同的遍历策略。  💡 提示: 核心思想遍历的本质是：按照数据结构的特性，用合适的方式访问每个元素一次，且仅一次。   一、数组遍历1.1 基本特性   特性 说明    存储方式 连续内存，随机访问   访问复杂度 O(1)   遍历复杂度">
<meta property="og:type" content="article">
<meta property="og:title" content="属性数据结构遍历详解">
<meta property="og:url" content="https://zmmmmy.github.io/2026/01/12/%E5%B1%9E%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Zmmmmy&#39;s Blog">
<meta property="og:description" content="属性数据结构遍历详解概述属性数据结构 是指具有特定属性或特征的数据结构，如有序性、层级性、连通性等。遍历是访问数据结构中所有元素的基本操作，不同的数据结构有不同的遍历策略。  💡 提示: 核心思想遍历的本质是：按照数据结构的特性，用合适的方式访问每个元素一次，且仅一次。   一、数组遍历1.1 基本特性   特性 说明    存储方式 连续内存，随机访问   访问复杂度 O(1)   遍历复杂度">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2026-01-11T16:00:00.000Z">
<meta property="article:modified_time" content="2026-01-22T07:44:14.988Z">
<meta property="article:author" content="ZhiMy">
<meta property="article:tag" content="属性结构">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="遍历">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zmmmmy.github.io/2026/01/12/%E5%B1%9E%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zmmmmy.github.io/2026/01/12/%E5%B1%9E%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/","path":"2026/01/12/属性数据结构遍历详解/","title":"属性数据结构遍历详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>属性数据结构遍历详解 | Zmmmmy's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zmmmmy's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">今天想和 AI 聊点什么？</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">属性数据结构遍历详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.</span> <span class="nav-text">一、数组遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.1 基本特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%81%8D%E5%8E%86%E6%80%9D%E8%B7%AF"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2 遍历思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.3 实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F1%EF%BC%9A%E4%BC%A0%E7%BB%9F-for-%E5%BE%AA%E7%8E%AF%EF%BC%88%E6%9C%80%E7%9B%B4%E6%8E%A5%EF%BC%89"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">方式1：传统 for 循环（最直接）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F2%EF%BC%9A%E5%A2%9E%E5%BC%BA-for-%E5%BE%AA%E7%8E%AF%EF%BC%88%E7%AE%80%E6%B4%81%EF%BC%89"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">方式2：增强 for 循环（简洁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F3%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%9A%E7%94%A8%EF%BC%89"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">方式3：迭代器遍历（通用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F4%EF%BC%9A%E6%B5%81%E5%BC%8F%E9%81%8D%E5%8E%86%EF%BC%88%E5%87%BD%E6%95%B0%E5%BC%8F%EF%BC%89"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">方式4：流式遍历（函数式）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.4.</span> <span class="nav-text">1.4 二维数组遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">按行遍历（最常用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">按列遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">对角线遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E9%81%8D%E5%8E%86%E5%8F%98%E7%A7%8D"><span class="nav-number">1.2.5.</span> <span class="nav-text">1.5 遍历变种</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">反向遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">跳跃遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">条件遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.</span> <span class="nav-text">二、链表遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.1.</span> <span class="nav-text">2.1 基本特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.2 链表节点定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%81%8D%E5%8E%86%E6%80%9D%E8%B7%AF"><span class="nav-number">1.3.3.</span> <span class="nav-text">2.3 遍历思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.4.</span> <span class="nav-text">2.4 实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F1%EF%BC%9Awhile-%E5%BE%AA%E7%8E%AF%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">方式1：while 循环（最常用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F2%EF%BC%9A%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">方式2：递归遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F3%EF%BC%9A%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">方式3：反向遍历（递归）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F4%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">方式4：快慢指针遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F5%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">方式5：迭代器遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.5.</span> <span class="nav-text">2.5 双向链表遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.</span> <span class="nav-text">三、树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.1 基本特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">1.4.2.</span> <span class="nav-text">3.2 树节点定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">二叉树节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">多叉树节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.3 深度优先遍历（DFS）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Pre-order%EF%BC%89"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">前序遍历（Pre-order）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88In-order%EF%BC%89"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">中序遍历（In-order）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Post-order%EF%BC%89"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">后序遍历（Post-order）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%A4%9A%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.4.</span> <span class="nav-text">3.4 多叉树遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">多叉树前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">多叉树后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">多叉树层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%94%E5%9B%9E%E6%AF%8F%E5%B1%82%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%89"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">分层遍历（返回每层的列表）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%A4%9A%E5%8F%89%E6%A0%91-vs-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E6%AF%94"><span class="nav-number">1.4.5.</span> <span class="nav-text">3.5 多叉树 vs 二叉树对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="nav-number">1.4.6.</span> <span class="nav-text">3.6 广度优先遍历（BFS）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Level-order%EF%BC%89"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">层序遍历（Level-order）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%94%E5%9B%9E%E6%AF%8F%E5%B1%82%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%89-1"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">分层遍历（返回每层的列表）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-DFS-vs-BFS-%E5%AF%B9%E6%AF%94"><span class="nav-number">1.4.7.</span> <span class="nav-text">3.5 DFS vs BFS 对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.5.</span> <span class="nav-text">四、图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.1.</span> <span class="nav-text">4.1 基本特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.5.2.</span> <span class="nav-text">4.2 图的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">4.3 深度优先遍历（DFS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="nav-number">1.5.4.</span> <span class="nav-text">4.4 广度优先遍历（BFS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-DFS-vs-BFS-%E5%AF%B9%E6%AF%94"><span class="nav-number">1.5.5.</span> <span class="nav-text">4.5 DFS vs BFS 对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.6.</span> <span class="nav-text">五、特殊数据结构遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%89%E9%81%8D%E5%8E%86"><span class="nav-number">1.6.1.</span> <span class="nav-text">5.1 二叉搜索树（BST）遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%A0%86%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.6.2.</span> <span class="nav-text">5.2 堆的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%93%88%E5%B8%8C%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="nav-number">1.6.3.</span> <span class="nav-text">5.3 哈希表遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.</span> <span class="nav-text">六、遍历的通用思路总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0"><span class="nav-number">1.7.1.</span> <span class="nav-text">6.1 遍历的三个核心要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E9%80%89%E6%8B%A9%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91"><span class="nav-number">1.7.2.</span> <span class="nav-text">6.2 选择遍历方式的决策树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E9%80%92%E5%BD%92-vs-%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.7.3.</span> <span class="nav-text">6.3 递归 vs 迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%B8%B8%E8%A7%81%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.</span> <span class="nav-text">七、常见遍历问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-number">1.8.1.</span> <span class="nav-text">7.1 如何在遍历中删除元素？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%8E%AF%E5%BD%A2%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">1.8.2.</span> <span class="nav-text">7.2 如何处理环形结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%8D%E8%BF%9E%E9%80%9A%E7%9A%84%E5%9B%BE%EF%BC%9F"><span class="nav-number">1.8.3.</span> <span class="nav-text">7.3 如何处理不连通的图？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="nav-number">1.9.</span> <span class="nav-text">八、性能对比总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0"><span class="nav-number">1.10.</span> <span class="nav-text">相关笔记</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhiMy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">ZhiMy</p>
  <div class="site-description" itemprop="description">一个来自于 AI+Obsidian 的知识库</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Zmmmmy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zmmmmy" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zmmmmy.github.io/2026/01/12/%E5%B1%9E%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="ZhiMy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zmmmmy's Blog">
      <meta itemprop="description" content="一个来自于 AI+Obsidian 的知识库">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="属性数据结构遍历详解 | Zmmmmy's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          属性数据结构遍历详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2026-01-12 00:00:00" itemprop="dateCreated datePublished" datetime="2026-01-12T00:00:00+08:00">2026-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-22 15:44:14" itemprop="dateModified" datetime="2026-01-22T15:44:14+08:00">2026-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="属性数据结构遍历详解"><a href="#属性数据结构遍历详解" class="headerlink" title="属性数据结构遍历详解"></a>属性数据结构遍历详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>属性数据结构</strong> 是指具有特定属性或特征的数据结构，如有序性、层级性、连通性等。遍历是访问数据结构中所有元素的基本操作，不同的数据结构有不同的遍历策略。</p>
<blockquote>
<p><strong>💡 提示: 核心思想</strong><br>遍历的本质是：<strong>按照数据结构的特性，用合适的方式访问每个元素一次，且仅一次</strong>。</p>
</blockquote>
<hr>
<h2 id="一、数组遍历"><a href="#一、数组遍历" class="headerlink" title="一、数组遍历"></a>一、数组遍历</h2><h3 id="1-1-基本特性"><a href="#1-1-基本特性" class="headerlink" title="1.1 基本特性"></a>1.1 基本特性</h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储方式</strong></td>
<td>连续内存，随机访问</td>
</tr>
<tr>
<td><strong>访问复杂度</strong></td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>遍历复杂度</strong></td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>属性</strong></td>
<td>有序、固定大小、可重复</td>
</tr>
</tbody></table>
<h3 id="1-2-遍历思路"><a href="#1-2-遍历思路" class="headerlink" title="1.2 遍历思路"></a>1.2 遍历思路</h3><p>数组遍历的核心思路是<strong>线性扫描</strong>：从第一个元素开始，依次访问每个元素，直到最后一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路流程：</span><br><span class="line">1. 初始化指针/索引 i = 0</span><br><span class="line">2. 检查 i &lt; 数组长度</span><br><span class="line">3. 访问 array[i]</span><br><span class="line">4. i++</span><br><span class="line">5. 回到步骤2</span><br></pre></td></tr></table></figure>

<h3 id="1-3-实现方式"><a href="#1-3-实现方式" class="headerlink" title="1.3 实现方式"></a>1.3 实现方式</h3><h4 id="方式1：传统-for-循环（最直接）"><a href="#方式1：传统-for-循环（最直接）" class="headerlink" title="方式1：传统 for 循环（最直接）"></a>方式1：传统 for 循环（最直接）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：需要索引值，需要提前知道数组大小</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);  <span class="comment">// 访问元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>显式控制索引，可以随意访问任何位置</li>
<li>适合需要索引的场景（如修改元素、计算位置等）</li>
</ul>
<h4 id="方式2：增强-for-循环（简洁）"><a href="#方式2：增强-for-循环（简洁）" class="headerlink" title="方式2：增强 for 循环（简洁）"></a>方式2：增强 for 循环（简洁）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：只需要元素值，不需要索引</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">    System.out.println(num);  <span class="comment">// 访问元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>隐藏索引细节，代码更简洁</li>
<li>本质上还是顺序访问</li>
<li>不能修改数组元素（对基本类型）</li>
</ul>
<h4 id="方式3：迭代器遍历（通用）"><a href="#方式3：迭代器遍历（通用）" class="headerlink" title="方式3：迭代器遍历（通用）"></a>方式3：迭代器遍历（通用）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：需要在遍历中删除元素</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">3</span>) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>迭代器维护遍历状态</li>
<li>支持在遍历中安全删除</li>
<li>适合集合框架</li>
</ul>
<h4 id="方式4：流式遍历（函数式）"><a href="#方式4：流式遍历（函数式）" class="headerlink" title="方式4：流式遍历（函数式）"></a>方式4：流式遍历（函数式）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：需要函数式编程风格</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.stream(arr)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者带索引</span></span><br><span class="line">IntStream.range(<span class="number">0</span>, arr.length)</span><br><span class="line">    .forEach(i -&gt; System.out.println(arr[i]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>声明式编程，表达意图清晰</li>
<li>支持链式操作和函数组合</li>
<li>可能有额外开销</li>
</ul>
<h3 id="1-4-二维数组遍历"><a href="#1-4-二维数组遍历" class="headerlink" title="1.4 二维数组遍历"></a>1.4 二维数组遍历</h3><h4 id="按行遍历（最常用）"><a href="#按行遍历（最常用）" class="headerlink" title="按行遍历（最常用）"></a>按行遍历（最常用）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 思路：外层循环遍历行，内层循环遍历列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">        System.out.println(matrix[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问顺序：1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(m*n)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>外层控制行，内层控制列</li>
<li>按行优先顺序访问（cache 友好）</li>
<li>适合大多数矩阵操作</li>
</ul>
<h4 id="按列遍历"><a href="#按列遍历" class="headerlink" title="按列遍历"></a>按列遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：外层循环遍历列，内层循环遍历行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        System.out.println(matrix[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问顺序：1 4 7 2 5 8 3 6 9</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(m*n)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>适合需要按列处理的场景</li>
<li>可能导致 cache miss（不如按行遍历高效）</li>
</ul>
<h4 id="对角线遍历"><a href="#对角线遍历" class="headerlink" title="对角线遍历"></a>对角线遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：按对角线方向遍历</span></span><br><span class="line"><span class="comment">// 第一条对角线：(0,0)</span></span><br><span class="line"><span class="comment">// 第二条对角线：(0,1), (1,0)</span></span><br><span class="line"><span class="comment">// 第三条对角线：(0,2), (1,1), (2,0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">diag</span> <span class="operator">=</span> <span class="number">0</span>; diag &lt; matrix.length + matrix[<span class="number">0</span>].length - <span class="number">1</span>; diag++) &#123;</span><br><span class="line">    <span class="comment">// 对于第 diag 条对角线</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, diag - matrix[<span class="number">0</span>].length + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">endRow</span> <span class="operator">=</span> Math.min(diag, matrix.length - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow; i &lt;= endRow; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> diag - i;</span><br><span class="line">        System.out.println(matrix[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问顺序：1 2 4 3 5 7 6 8 9</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(m*n)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>对角线编号：i + j &#x3D; diag</li>
<li>需要计算每条对角线的起点和终点</li>
<li>适合特定的矩阵问题</li>
</ul>
<h3 id="1-5-遍历变种"><a href="#1-5-遍历变种" class="headerlink" title="1.5 遍历变种"></a>1.5 遍历变种</h3><h4 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从后往前遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用场景：</span></span><br><span class="line"><span class="comment">// 1. 需要从后往前处理</span></span><br><span class="line"><span class="comment">// 2. 删除元素时避免索引混乱</span></span><br></pre></td></tr></table></figure>

<h4 id="跳跃遍历"><a href="#跳跃遍历" class="headerlink" title="跳跃遍历"></a>跳跃遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每隔 k 个元素访问一个</span></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i += k) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用场景：</span></span><br><span class="line"><span class="comment">// 1. 采样</span></span><br><span class="line"><span class="comment">// 2. 步长遍历</span></span><br></pre></td></tr></table></figure>

<h4 id="条件遍历"><a href="#条件遍历" class="headerlink" title="条件遍历"></a>条件遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只遍历满足条件的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用流</span></span><br><span class="line">Arrays.stream(arr)</span><br><span class="line">    .filter(x -&gt; x &gt; <span class="number">5</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、链表遍历"><a href="#二、链表遍历" class="headerlink" title="二、链表遍历"></a>二、链表遍历</h2><h3 id="2-1-基本特性"><a href="#2-1-基本特性" class="headerlink" title="2.1 基本特性"></a>2.1 基本特性</h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储方式</strong></td>
<td>离散内存，通过指针连接</td>
</tr>
<tr>
<td><strong>访问复杂度</strong></td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>遍历复杂度</strong></td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>属性</strong></td>
<td>有序、动态大小、可重复</td>
</tr>
</tbody></table>
<h3 id="2-2-链表节点定义"><a href="#2-2-链表节点定义" class="headerlink" title="2.2 链表节点定义"></a>2.2 链表节点定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;           <span class="comment">// 数据</span></span><br><span class="line">    ListNode next;     <span class="comment">// 指向下一个节点</span></span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-遍历思路"><a href="#2-3-遍历思路" class="headerlink" title="2.3 遍历思路"></a>2.3 遍历思路</h3><p>链表遍历的核心思路是<strong>指针跟踪</strong>：从头节点开始，通过 next 指针逐个访问每个节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路流程：</span><br><span class="line">1. 初始化指针 current = head</span><br><span class="line">2. 检查 current != null</span><br><span class="line">3. 访问 current.val</span><br><span class="line">4. current = current.next</span><br><span class="line">5. 回到步骤2</span><br></pre></td></tr></table></figure>

<h3 id="2-4-实现方式"><a href="#2-4-实现方式" class="headerlink" title="2.4 实现方式"></a>2.4 实现方式</h3><h4 id="方式1：while-循环（最常用）"><a href="#方式1：while-循环（最常用）" class="headerlink" title="方式1：while 循环（最常用）"></a>方式1：while 循环（最常用）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：需要逐个访问节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(current.val);  <span class="comment">// 访问节点</span></span><br><span class="line">    current = current.next;            <span class="comment">// 移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>最直接的遍历方式</li>
<li>通过 null 检查确定遍历结束</li>
<li>不修改链表结构</li>
</ul>
<h4 id="方式2：递归遍历"><a href="#方式2：递归遍历" class="headerlink" title="方式2：递归遍历"></a>方式2：递归遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：需要递归处理或反向遍历</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 递归终止条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(node.val);      <span class="comment">// 前序处理</span></span><br><span class="line">    traverse(node.next);               <span class="comment">// 递归访问下一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">traverse(head);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)（递归栈）</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>递归天然适合链表结构</li>
<li>空间复杂度较高（栈深度）</li>
<li>适合需要反向处理的场景</li>
</ul>
<h4 id="方式3：反向遍历（递归）"><a href="#方式3：反向遍历（递归）" class="headerlink" title="方式3：反向遍历（递归）"></a>方式3：反向遍历（递归）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：需要从后往前访问</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reverseTraverse</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverseTraverse(node.next);        <span class="comment">// 先递归到末尾</span></span><br><span class="line">    System.out.println(node.val);      <span class="comment">// 后序处理（反向）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">reverseTraverse(head);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：3 2 1（如果链表是 1-&gt;2-&gt;3）</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>利用递归栈实现反向遍历</li>
<li>不需要额外的反向链表</li>
<li>空间复杂度 O(n)</li>
</ul>
<h4 id="方式4：快慢指针遍历"><a href="#方式4：快慢指针遍历" class="headerlink" title="方式4：快慢指针遍历"></a>方式4：快慢指针遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：需要找到中点、检测环等</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 思路：slow 每次走一步，fast 每次走两步</span></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slow 现在指向中点</span></span><br><span class="line">System.out.println(<span class="string">&quot;中点值：&quot;</span> + slow.val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>快指针速度是慢指针的两倍</li>
<li>当快指针到达末尾时，慢指针在中点</li>
<li>适合检测环、找中点等</li>
</ul>
<h4 id="方式5：迭代器遍历"><a href="#方式5：迭代器遍历" class="headerlink" title="方式5：迭代器遍历"></a>方式5：迭代器遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：使用集合框架</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>隐藏指针细节</li>
<li>支持在遍历中删除</li>
<li>更安全的遍历方式</li>
</ul>
<h3 id="2-5-双向链表遍历"><a href="#2-5-双向链表遍历" class="headerlink" title="2.5 双向链表遍历"></a>2.5 双向链表遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    DoublyListNode prev;  <span class="comment">// 前驱指针</span></span><br><span class="line">    DoublyListNode next;  <span class="comment">// 后继指针</span></span><br><span class="line">    </span><br><span class="line">    DoublyListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正向遍历</span></span><br><span class="line"><span class="type">DoublyListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(current.val);</span><br><span class="line">    current = current.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向遍历（利用 prev 指针）</span></span><br><span class="line">current = tail;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(current.val);</span><br><span class="line">    current = current.prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>双向链表支持双向遍历</li>
<li>反向遍历不需要递归</li>
<li>适合需要双向访问的场景</li>
</ul>
<hr>
<h2 id="三、树的遍历"><a href="#三、树的遍历" class="headerlink" title="三、树的遍历"></a>三、树的遍历</h2><h3 id="3-1-基本特性"><a href="#3-1-基本特性" class="headerlink" title="3.1 基本特性"></a>3.1 基本特性</h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储方式</strong></td>
<td>层级结构，父子关系</td>
</tr>
<tr>
<td><strong>访问复杂度</strong></td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>遍历复杂度</strong></td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>属性</strong></td>
<td>有序、非线性、无环</td>
</tr>
</tbody></table>
<h3 id="3-2-树节点定义"><a href="#3-2-树节点定义" class="headerlink" title="3.2 树节点定义"></a>3.2 树节点定义</h3><h4 id="二叉树节点"><a href="#二叉树节点" class="headerlink" title="二叉树节点"></a>二叉树节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;              <span class="comment">// 数据</span></span><br><span class="line">    TreeNode left;        <span class="comment">// 左子树</span></span><br><span class="line">    TreeNode right;       <span class="comment">// 右子树</span></span><br><span class="line">    </span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多叉树节点"><a href="#多叉树节点" class="headerlink" title="多叉树节点"></a>多叉树节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NaryTreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;                          <span class="comment">// 数据</span></span><br><span class="line">    List&lt;NaryTreeNode&gt; children;      <span class="comment">// 子节点列表</span></span><br><span class="line">    </span><br><span class="line">    NaryTreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>每个节点可以有任意数量的子节点</li>
<li>适合表示文件系统、组织结构等</li>
<li>遍历逻辑更通用</li>
</ul>
<h3 id="3-3-深度优先遍历（DFS）"><a href="#3-3-深度优先遍历（DFS）" class="headerlink" title="3.3 深度优先遍历（DFS）"></a>3.3 深度优先遍历（DFS）</h3><h4 id="前序遍历（Pre-order）"><a href="#前序遍历（Pre-order）" class="headerlink" title="前序遍历（Pre-order）"></a>前序遍历（Pre-order）</h4><p><strong>遍历顺序</strong>：根 → 左子树 → 右子树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路流程：</span><br><span class="line">1. 访问当前节点</span><br><span class="line">2. 递归遍历左子树</span><br><span class="line">3. 递归遍历右子树</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(node.val);      <span class="comment">// 1. 访问根</span></span><br><span class="line">    preorder(node.left);               <span class="comment">// 2. 遍历左子树</span></span><br><span class="line">    preorder(node.right);              <span class="comment">// 3. 遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例树：</span></span><br><span class="line"><span class="comment">//       1</span></span><br><span class="line"><span class="comment">//      / \</span></span><br><span class="line"><span class="comment">//     2   3</span></span><br><span class="line"><span class="comment">// 输出：1 2 3</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>最先访问根节点</li>
<li>适合需要先处理父节点的场景</li>
<li>如：复制树、序列化树</li>
</ul>
<p><strong>迭代实现</strong>（使用栈）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">preorderIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：先压右子树，后压左子树</span></span><br><span class="line">        <span class="comment">// 这样弹出时左子树先出</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(h)，h 是树的高度</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>栈模拟递归调用</li>
<li>压栈顺序很关键（右先压，左后压）</li>
<li>避免递归栈溢出</li>
</ul>
<h4 id="中序遍历（In-order）"><a href="#中序遍历（In-order）" class="headerlink" title="中序遍历（In-order）"></a>中序遍历（In-order）</h4><p><strong>遍历顺序</strong>：左子树 → 根 → 右子树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路流程：</span><br><span class="line">1. 递归遍历左子树</span><br><span class="line">2. 访问当前节点</span><br><span class="line">3. 递归遍历右子树</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    inorder(node.left);                <span class="comment">// 1. 遍历左子树</span></span><br><span class="line">    System.out.println(node.val);      <span class="comment">// 2. 访问根</span></span><br><span class="line">    inorder(node.right);               <span class="comment">// 3. 遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例树：</span></span><br><span class="line"><span class="comment">//       2</span></span><br><span class="line"><span class="comment">//      / \</span></span><br><span class="line"><span class="comment">//     1   3</span></span><br><span class="line"><span class="comment">// 输出：1 2 3</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>对于二叉搜索树，中序遍历得到有序序列</li>
<li>适合需要有序处理的场景</li>
<li>最常用的遍历方式</li>
</ul>
<p><strong>迭代实现</strong>（使用栈）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">inorderIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 1. 一直向左走，压栈所有左节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 左子树遍历完，弹出栈顶（根）</span></span><br><span class="line">        current = stack.pop();</span><br><span class="line">        System.out.println(current.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 遍历右子树</span></span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(h)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>关键：先一直向左，直到 null</li>
<li>然后处理栈顶，再向右</li>
<li>比前序遍历更复杂</li>
</ul>
<h4 id="后序遍历（Post-order）"><a href="#后序遍历（Post-order）" class="headerlink" title="后序遍历（Post-order）"></a>后序遍历（Post-order）</h4><p><strong>遍历顺序</strong>：左子树 → 右子树 → 根</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路流程：</span><br><span class="line">1. 递归遍历左子树</span><br><span class="line">2. 递归遍历右子树</span><br><span class="line">3. 访问当前节点</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    postorder(node.left);              <span class="comment">// 1. 遍历左子树</span></span><br><span class="line">    postorder(node.right);             <span class="comment">// 2. 遍历右子树</span></span><br><span class="line">    System.out.println(node.val);      <span class="comment">// 3. 访问根</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例树：</span></span><br><span class="line"><span class="comment">//       3</span></span><br><span class="line"><span class="comment">//      / \</span></span><br><span class="line"><span class="comment">//     1   2</span></span><br><span class="line"><span class="comment">// 输出：1 2 3</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>最后访问根节点</li>
<li>适合需要先处理子节点的场景</li>
<li>如：删除树、计算树的高度</li>
</ul>
<p><strong>迭代实现</strong>（使用两个栈）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">postorderIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    stack1.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次遍历：根 → 右 → 左（反向的后序）</span></span><br><span class="line">    <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">        stack2.push(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack1.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack1.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二次遍历：弹出 stack2（得到正确的后序）</span></span><br><span class="line">    <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">        System.out.println(stack2.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>使用两个栈实现</li>
<li>第一个栈生成反向后序</li>
<li>第二个栈反转得到正确顺序</li>
</ul>
<h3 id="3-4-多叉树遍历"><a href="#3-4-多叉树遍历" class="headerlink" title="3.4 多叉树遍历"></a>3.4 多叉树遍历</h3><h4 id="多叉树前序遍历"><a href="#多叉树前序遍历" class="headerlink" title="多叉树前序遍历"></a>多叉树前序遍历</h4><p><strong>遍历顺序</strong>：根 → 所有子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preorderNary</span><span class="params">(NaryTreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(node.val);      <span class="comment">// 1. 访问根</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 遍历所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (NaryTreeNode child : node.children) &#123;</span><br><span class="line">        preorderNary(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例树：</span></span><br><span class="line"><span class="comment">//         1</span></span><br><span class="line"><span class="comment">//      /  |  \</span></span><br><span class="line"><span class="comment">//     2   3   4</span></span><br><span class="line"><span class="comment">//    / \</span></span><br><span class="line"><span class="comment">//   5   6</span></span><br><span class="line"><span class="comment">// 输出：1 2 5 6 3 4</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>与二叉树前序类似，先访问根</li>
<li>遍历所有子节点而不是只有左右</li>
<li>时间复杂度 O(n)，空间复杂度 O(h)</li>
</ul>
<p><strong>迭代实现</strong>（使用栈）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">preorderNaryIterative</span><span class="params">(NaryTreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;NaryTreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">NaryTreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关键：反向压栈子节点，保证正确的访问顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> node.children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            stack.push(node.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(h)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>反向压栈是关键（从最后一个子节点开始）</li>
<li>这样弹出时，第一个子节点先出</li>
<li>保证了正确的前序遍历顺序</li>
</ul>
<h4 id="多叉树后序遍历"><a href="#多叉树后序遍历" class="headerlink" title="多叉树后序遍历"></a>多叉树后序遍历</h4><p><strong>遍历顺序</strong>：所有子节点 → 根</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postorderNary</span><span class="params">(NaryTreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 遍历所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (NaryTreeNode child : node.children) &#123;</span><br><span class="line">        postorderNary(child);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(node.val);      <span class="comment">// 2. 访问根</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例树同上</span></span><br><span class="line"><span class="comment">// 输出：5 6 2 3 4 1</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>先处理所有子节点，最后处理根</li>
<li>适合需要先处理子树的场景（如删除树）</li>
<li>时间复杂度 O(n)，空间复杂度 O(h)</li>
</ul>
<p><strong>迭代实现</strong>（使用两个栈）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">postorderNaryIterative</span><span class="params">(NaryTreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;NaryTreeNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;NaryTreeNode&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    stack1.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次遍历：生成反向的后序</span></span><br><span class="line">    <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">        <span class="type">NaryTreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">        stack2.push(node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正向压栈子节点</span></span><br><span class="line">        <span class="keyword">for</span> (NaryTreeNode child : node.children) &#123;</span><br><span class="line">            stack1.push(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二次遍历：弹出 stack2</span></span><br><span class="line">    <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">        System.out.println(stack2.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>与二叉树后序类似，使用两个栈</li>
<li>第一个栈生成反向后序</li>
<li>第二个栈反转得到正确顺序</li>
</ul>
<h4 id="多叉树层序遍历"><a href="#多叉树层序遍历" class="headerlink" title="多叉树层序遍历"></a>多叉树层序遍历</h4><p><strong>遍历顺序</strong>：按层从上到下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">levelorderNary</span><span class="params">(NaryTreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;NaryTreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">NaryTreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将所有子节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (NaryTreeNode child : node.children) &#123;</span><br><span class="line">            queue.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>队列保证层序访问</li>
<li>遍历所有子节点而不是只有左右</li>
<li>时间复杂度 O(n)，空间复杂度 O(w)</li>
</ul>
<h4 id="分层遍历（返回每层的列表）"><a href="#分层遍历（返回每层的列表）" class="headerlink" title="分层遍历（返回每层的列表）"></a>分层遍历（返回每层的列表）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelorderNaryList</span><span class="params">(NaryTreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;NaryTreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size();  <span class="comment">// 记录当前层的节点数</span></span><br><span class="line">        List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理当前层的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">            <span class="type">NaryTreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            currentLevel.add(node.val);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将所有子节点加入队列</span></span><br><span class="line">            <span class="keyword">for</span> (NaryTreeNode child : node.children) &#123;</span><br><span class="line">                queue.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result.add(currentLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：[[1], [2, 3, 4], [5, 6]]</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>关键：记录每层的节点数</li>
<li>在处理当前层时，只处理 levelSize 个节点</li>
<li>这样可以清晰地分离各层</li>
</ul>
<h3 id="3-5-多叉树-vs-二叉树对比"><a href="#3-5-多叉树-vs-二叉树对比" class="headerlink" title="3.5 多叉树 vs 二叉树对比"></a>3.5 多叉树 vs 二叉树对比</h3><table>
<thead>
<tr>
<th>维度</th>
<th>二叉树</th>
<th>多叉树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>子节点数</strong></td>
<td>最多 2 个</td>
<td>任意个</td>
</tr>
<tr>
<td><strong>前序遍历</strong></td>
<td>根→左→右</td>
<td>根→所有子</td>
</tr>
<tr>
<td><strong>后序遍历</strong></td>
<td>左→右→根</td>
<td>所有子→根</td>
</tr>
<tr>
<td><strong>中序遍历</strong></td>
<td>左→根→右</td>
<td>不适用</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>搜索树、堆</td>
<td>文件系统、组织结构</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>简单</td>
<td>稍复杂（循环遍历子节点）</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-6-广度优先遍历（BFS）"><a href="#3-6-广度优先遍历（BFS）" class="headerlink" title="3.6 广度优先遍历（BFS）"></a>3.6 广度优先遍历（BFS）</h3><h4 id="层序遍历（Level-order）"><a href="#层序遍历（Level-order）" class="headerlink" title="层序遍历（Level-order）"></a>层序遍历（Level-order）</h4><p><strong>遍历顺序</strong>：按层从上到下，同层从左到右</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路流程：</span><br><span class="line">1. 初始化队列，放入根节点</span><br><span class="line">2. 队列不为空时：</span><br><span class="line">   a. 弹出队列前端节点</span><br><span class="line">   b. 访问该节点</span><br><span class="line">   c. 将其子节点加入队列</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用队列实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例树：</span></span><br><span class="line"><span class="comment">//       1</span></span><br><span class="line"><span class="comment">//      / \</span></span><br><span class="line"><span class="comment">//     2   3</span></span><br><span class="line"><span class="comment">//    / \</span></span><br><span class="line"><span class="comment">//   4   5</span></span><br><span class="line"><span class="comment">// 输出：1 2 3 4 5</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>队列保证了层序访问</li>
<li>先进先出的特性很关键</li>
<li>适合需要按层处理的场景</li>
</ul>
<h4 id="分层遍历（返回每层的列表）-1"><a href="#分层遍历（返回每层的列表）-1" class="headerlink" title="分层遍历（返回每层的列表）"></a>分层遍历（返回每层的列表）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderList</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size();  <span class="comment">// 关键：记录当前层的节点数</span></span><br><span class="line">        List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理当前层的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            currentLevel.add(node.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result.add(currentLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：[[1], [2, 3], [4, 5]]</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>关键：记录每层的节点数</li>
<li>在处理当前层时，只处理 levelSize 个节点</li>
<li>这样可以清晰地分离各层</li>
</ul>
<h3 id="3-5-DFS-vs-BFS-对比"><a href="#3-5-DFS-vs-BFS-对比" class="headerlink" title="3.5 DFS vs BFS 对比"></a>3.5 DFS vs BFS 对比</h3><table>
<thead>
<tr>
<th>维度</th>
<th>DFS（递归&#x2F;栈）</th>
<th>BFS（队列）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现</strong></td>
<td>递归或栈</td>
<td>队列</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>O(h)（高度）</td>
<td>O(w)（最大宽度）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>路径问题、深度问题</td>
<td>最短路径、层级问题</td>
</tr>
<tr>
<td><strong>遍历顺序</strong></td>
<td>深度优先</td>
<td>广度优先</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、图的遍历"><a href="#四、图的遍历" class="headerlink" title="四、图的遍历"></a>四、图的遍历</h2><h3 id="4-1-基本特性"><a href="#4-1-基本特性" class="headerlink" title="4.1 基本特性"></a>4.1 基本特性</h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储方式</strong></td>
<td>邻接表或邻接矩阵</td>
</tr>
<tr>
<td><strong>访问复杂度</strong></td>
<td>O(V+E)</td>
</tr>
<tr>
<td><strong>遍历复杂度</strong></td>
<td>O(V+E)</td>
</tr>
<tr>
<td><strong>属性</strong></td>
<td>可能有环、可能不连通</td>
</tr>
</tbody></table>
<h3 id="4-2-图的表示"><a href="#4-2-图的表示" class="headerlink" title="4.2 图的表示"></a>4.2 图的表示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表表示</span></span><br><span class="line">Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">graph.put(<span class="number">1</span>, Arrays.asList(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">graph.put(<span class="number">2</span>, Arrays.asList(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">graph.put(<span class="number">3</span>, Arrays.asList(<span class="number">1</span>));</span><br><span class="line">graph.put(<span class="number">4</span>, Arrays.asList(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵表示</span></span><br><span class="line"><span class="type">int</span>[][] adjMatrix = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,  <span class="comment">// 节点 0 的邻接</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,  <span class="comment">// 节点 1 的邻接</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// 节点 2 的邻接</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;   <span class="comment">// 节点 3 的邻接</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-深度优先遍历（DFS）"><a href="#4-3-深度优先遍历（DFS）" class="headerlink" title="4.3 深度优先遍历（DFS）"></a>4.3 深度优先遍历（DFS）</h3><p><strong>思路</strong>：从起点开始，沿着一条路径尽可能深地探索，直到无法继续，然后回溯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node, Map&lt;Integer, List&lt;Integer&gt;&gt; graph, Set&lt;Integer&gt; visited)</span> &#123;</span><br><span class="line">    visited.add(node);</span><br><span class="line">    System.out.println(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">            dfs(neighbor, graph, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">dfs(<span class="number">1</span>, graph, visited);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(V+E)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(V)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>使用 visited 集合防止重复访问（处理环）</li>
<li>递归自然地实现了深度优先</li>
<li>适合检测环、拓扑排序等</li>
</ul>
<p><strong>迭代实现</strong>（使用栈）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfsIterative</span><span class="params">(<span class="type">int</span> start, Map&lt;Integer, List&lt;Integer&gt;&gt; graph)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    stack.push(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (visited.contains(node)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited.add(node);</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 压栈所有未访问的邻接节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                stack.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(V+E)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(V)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>栈模拟递归</li>
<li>需要检查是否已访问</li>
<li>避免重复处理</li>
</ul>
<h3 id="4-4-广度优先遍历（BFS）"><a href="#4-4-广度优先遍历（BFS）" class="headerlink" title="4.4 广度优先遍历（BFS）"></a>4.4 广度优先遍历（BFS）</h3><p><strong>思路</strong>：从起点开始，逐层探索所有邻接节点，然后探索下一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start, Map&lt;Integer, List&lt;Integer&gt;&gt; graph)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    queue.add(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                visited.add(neighbor);</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(V+E)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(V)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>队列保证了广度优先</li>
<li>访问时就标记，避免重复加入队列</li>
<li>适合最短路径问题</li>
</ul>
<h3 id="4-5-DFS-vs-BFS-对比"><a href="#4-5-DFS-vs-BFS-对比" class="headerlink" title="4.5 DFS vs BFS 对比"></a>4.5 DFS vs BFS 对比</h3><table>
<thead>
<tr>
<th>维度</th>
<th>DFS</th>
<th>BFS</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据结构</strong></td>
<td>栈</td>
<td>队列</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>O(V)</td>
<td>O(V)</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>连通性、环检测、拓扑排序</td>
<td>最短路径、分层</td>
</tr>
<tr>
<td><strong>遍历顺序</strong></td>
<td>深度优先</td>
<td>广度优先</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、特殊数据结构遍历"><a href="#五、特殊数据结构遍历" class="headerlink" title="五、特殊数据结构遍历"></a>五、特殊数据结构遍历</h2><h3 id="5-1-二叉搜索树（BST）遍历"><a href="#5-1-二叉搜索树（BST）遍历" class="headerlink" title="5.1 二叉搜索树（BST）遍历"></a>5.1 二叉搜索树（BST）遍历</h3><p><strong>特性</strong>：左子树 &lt; 根 &lt; 右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历得到有序序列</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inorderBST</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    inorderBST(node.left);</span><br><span class="line">    System.out.println(node.val);  <span class="comment">// 输出有序</span></span><br><span class="line">    inorderBST(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="comment">//       5</span></span><br><span class="line"><span class="comment">//      / \</span></span><br><span class="line"><span class="comment">//     3   7</span></span><br><span class="line"><span class="comment">//    / \ / \</span></span><br><span class="line"><span class="comment">//   2  4 6  8</span></span><br><span class="line"><span class="comment">// 中序输出：2 3 4 5 6 7 8</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>中序遍历的特殊应用</li>
<li>利用 BST 的有序性</li>
<li>时间复杂度 O(n)</li>
</ul>
<h3 id="5-2-堆的遍历"><a href="#5-2-堆的遍历" class="headerlink" title="5.2 堆的遍历"></a>5.2 堆的遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆通常用数组表示</span></span><br><span class="line"><span class="type">int</span>[] heap = &#123;<span class="number">10</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按数组顺序遍历（层序）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heap.length; i++) &#123;</span><br><span class="line">    System.out.println(heap[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点关系：</span></span><br><span class="line"><span class="comment">// 节点 i 的左子节点：2*i + 1</span></span><br><span class="line"><span class="comment">// 节点 i 的右子节点：2*i + 2</span></span><br><span class="line"><span class="comment">// 节点 i 的父节点：(i-1)/2</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>堆用数组表示，按层序存储</li>
<li>遍历就是按数组顺序访问</li>
<li>时间复杂度 O(n)</li>
</ul>
<h3 id="5-3-哈希表遍历"><a href="#5-3-哈希表遍历" class="headerlink" title="5.3 哈希表遍历"></a>5.3 哈希表遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：遍历 key</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：遍历 value</span></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：遍历 entry（最高效）</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式4：迭代器</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>思路分析</strong>：</p>
<ul>
<li>遍历 entry 最高效（避免重复查询）</li>
<li>哈希表无序，遍历顺序不确定</li>
<li>遍历中删除需要用迭代器</li>
</ul>
<hr>
<h2 id="六、遍历的通用思路总结"><a href="#六、遍历的通用思路总结" class="headerlink" title="六、遍历的通用思路总结"></a>六、遍历的通用思路总结</h2><h3 id="6-1-遍历的三个核心要素"><a href="#6-1-遍历的三个核心要素" class="headerlink" title="6.1 遍历的三个核心要素"></a>6.1 遍历的三个核心要素</h3><table>
<thead>
<tr>
<th>要素</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>访问顺序</strong></td>
<td>按什么顺序访问元素</td>
<td>前序、中序、后序、层序</td>
</tr>
<tr>
<td><strong>状态管理</strong></td>
<td>如何跟踪已访问的元素</td>
<td>visited 集合、指针位置</td>
</tr>
<tr>
<td><strong>终止条件</strong></td>
<td>何时停止遍历</td>
<td>null、队列为空、visited 完全</td>
</tr>
</tbody></table>
<h3 id="6-2-选择遍历方式的决策树"><a href="#6-2-选择遍历方式的决策树" class="headerlink" title="6.2 选择遍历方式的决策树"></a>6.2 选择遍历方式的决策树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">需要遍历数据结构</span><br><span class="line">    ↓</span><br><span class="line">是否需要特定顺序？</span><br><span class="line">    ├─ 是 → 选择对应的遍历方式</span><br><span class="line">    │       ├─ 前序：先处理父节点</span><br><span class="line">    │       ├─ 中序：有序处理（BST）</span><br><span class="line">    │       ├─ 后序：先处理子节点</span><br><span class="line">    │       └─ 层序：按层处理</span><br><span class="line">    │</span><br><span class="line">    └─ 否 → 选择最简单的方式</span><br><span class="line">            ├─ 线性结构 → for 循环</span><br><span class="line">            ├─ 树 → DFS 或 BFS</span><br><span class="line">            └─ 图 → DFS 或 BFS</span><br></pre></td></tr></table></figure>

<h3 id="6-3-递归-vs-迭代"><a href="#6-3-递归-vs-迭代" class="headerlink" title="6.3 递归 vs 迭代"></a>6.3 递归 vs 迭代</h3><table>
<thead>
<tr>
<th>维度</th>
<th>递归</th>
<th>迭代</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码简洁性</strong></td>
<td>简洁</td>
<td>复杂</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>O(h)（栈）</td>
<td>O(h)（栈）</td>
</tr>
<tr>
<td><strong>栈溢出风险</strong></td>
<td>高（深度大）</td>
<td>低</td>
</tr>
<tr>
<td><strong>理解难度</strong></td>
<td>容易</td>
<td>较难</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>略低（函数调用）</td>
<td>略高</td>
</tr>
</tbody></table>
<hr>
<h2 id="七、常见遍历问题"><a href="#七、常见遍历问题" class="headerlink" title="七、常见遍历问题"></a>七、常见遍历问题</h2><h3 id="7-1-如何在遍历中删除元素？"><a href="#7-1-如何在遍历中删除元素？" class="headerlink" title="7.1 如何在遍历中删除元素？"></a>7.1 如何在遍历中删除元素？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误方式：直接删除</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.get(i) == <span class="number">3</span>) &#123;</span><br><span class="line">        list.remove(i);  <span class="comment">// 会导致索引混乱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确方式1：使用迭代器</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next() == <span class="number">3</span>) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确方式2：反向遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.get(i) == <span class="number">3</span>) &#123;</span><br><span class="line">        list.remove(i);  <span class="comment">// 不影响后续索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确方式3：收集要删除的元素</span></span><br><span class="line">List&lt;Integer&gt; toRemove = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">3</span>) &#123;</span><br><span class="line">        toRemove.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list.removeAll(toRemove);</span><br></pre></td></tr></table></figure>

<h3 id="7-2-如何处理环形结构？"><a href="#7-2-如何处理环形结构？" class="headerlink" title="7.2 如何处理环形结构？"></a>7.2 如何处理环形结构？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：链表中可能有环</span></span><br><span class="line"><span class="comment">// 解决：使用 visited 集合或快慢指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：visited 集合</span></span><br><span class="line">Set&lt;ListNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.contains(current)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检测到环&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited.add(current);</span><br><span class="line">    current = current.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：快慢指针（Floyd 算法）</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检测到环&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-如何处理不连通的图？"><a href="#7-3-如何处理不连通的图？" class="headerlink" title="7.3 如何处理不连通的图？"></a>7.3 如何处理不连通的图？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：图可能有多个连通分量</span></span><br><span class="line"><span class="comment">// 解决：对每个未访问的节点进行 DFS/BFS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverseAllComponents</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> node : graph.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(node)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--- 新的连通分量 ---&quot;</span>);</span><br><span class="line">            dfs(node, graph, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、性能对比总结"><a href="#八、性能对比总结" class="headerlink" title="八、性能对比总结"></a>八、性能对比总结</h2><table>
<thead>
<tr>
<th>数据结构</th>
<th>遍历方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>for 循环</td>
<td>O(n)</td>
<td>O(1)</td>
<td>顺序访问</td>
</tr>
<tr>
<td>链表</td>
<td>while 循环</td>
<td>O(n)</td>
<td>O(1)</td>
<td>顺序访问</td>
</tr>
<tr>
<td>树</td>
<td>DFS（递归）</td>
<td>O(n)</td>
<td>O(h)</td>
<td>深度优先</td>
</tr>
<tr>
<td>树</td>
<td>BFS（队列）</td>
<td>O(n)</td>
<td>O(w)</td>
<td>广度优先</td>
</tr>
<tr>
<td>图</td>
<td>DFS</td>
<td>O(V+E)</td>
<td>O(V)</td>
<td>连通性检测</td>
</tr>
<tr>
<td>图</td>
<td>BFS</td>
<td>O(V+E)</td>
<td>O(V)</td>
<td>最短路径</td>
</tr>
<tr>
<td>哈希表</td>
<td>entry 遍历</td>
<td>O(n)</td>
<td>O(1)</td>
<td>键值对访问</td>
</tr>
</tbody></table>
<hr>
<h2 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h2><ul>
<li>数组操作详解</li>
<li>链表操作详解</li>
<li>树的操作详解</li>
<li>图的操作详解</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>ZhiMy
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://zmmmmy.github.io/2026/01/12/%E5%B1%9E%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/" title="属性数据结构遍历详解">https://zmmmmy.github.io/2026/01/12/属性数据结构遍历详解/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/%E9%81%8D%E5%8E%86/" rel="tag"># 遍历</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84/" rel="tag"># 属性结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2026/01/12/%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/" rel="prev" title="多模块项目设计">
                  <i class="fa fa-angle-left"></i> 多模块项目设计
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2026/01/12/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" rel="next" title="大模型学习路线">
                  大模型学习路线 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZhiMy</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
